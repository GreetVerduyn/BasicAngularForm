= Theory

Angular is a platform and framework for building single-page client applications using HTML and TypeScript.
It implements core and optional functionality as a set of TypeScript libraries that you import into your applications.

The architecture of an Angular application relies on certain fundamental concepts.
The basic building blocks of the Angular framework are Angular components that are organized into NgModules.
An application always has at least a root module that enables bootstrapping, and typically has many more feature modules.
Modules, components and services are classes that use decorators. These decorators mark their type and provide metadata
that tells Angular how to use them.
An application's components (app.component.html) typically define many views, arranged hierarchically.
Angular provides the Router service to help you define navigation paths among views.
The router provides sophisticated in-browser navigational capabilities.

. Components:
 - Each component has an .html (the view, also called template), a .CSS (format) and  a .ts (code/data).
 - The code is written in the TS and called in the HTML bij "{{ }}".
 - Components define views, which are sets of screen elements that Angular can choose among and modify according to your program logic and data
 - Components use services, which provide specific functionality not directly related to views.

. Services:
 - Services providers can be injected into components as dependencies, making your code modular, reusable, and efficient.
 - it provides 'communication' between several components, api, ...

. Modules: NgModules collect related code into functional sets (services, components,...)

. Decorators: (@Component, @NgModule, ...)
 - decorators mark the type of classes and provide metadata that tells Angular how to use them.
   It gives extra functionality to an existing class.
 - You can use more than 1 decorator for a class

. Metadata:
- The metadata for a service class (given by a decorator) provides the information Angular needs to make it
available to components through dependency injection (DI)

. other elements:
 - directives: can make changes to your html ( *ngForm, *ngIf, ...)
 - pipes (|):are used to convert data
   (for example to filter, convert data to json, ...)

== Key features:
1. input properties (template events):
    -  value property

        in .html:
        <input class="demo value="test"> (plain string in the value property)
        <input class="demo [value]="data.title"> (in this *value property*, we put the value of the value.data expression (from the .ts))

        in .ts:
        export class nameOfClass {
             data = {
             title: 'Angular test'
             };
        }

        in .css: (formatting the file)
            input.demo {
                 border:...
                 width:...
                 ...
            }


    - give name to elements (template reference)

        in .html:
            <input class="demo [value]="data.title" #titleInput>
        Now you can refer to it in all the .html

        in .ts:
            export class nameOfClass {
                data = {
                    title: 'Angular test'
                };
            }

        in .css: (formatting the file)



2. browser events

    - (vb onKeyUp):

        in .html:
        <input class="demo (keyup)= "onKeyUp(titleInput.value)"
                [value]="data.title" #titleInput>
        => Now we refer to the #titleInput (from above)


        in .ts:
             export class nameOfClass {
                 data= {
                    title: 'Angular Test'
                    }
                onKeyUp(newTitle:string){
                    this.data.title = newTitle;
                }
            => now data.title is not 'Angular Test' anymore, but what is typed in the inputbox.

        in .css: (formatting the file)


     - (vb click event):

        in .html:
             <img width="300" (click)="inLogoClicked()"
                 alt="Angular Logo" src=data">

        in .ts:
             export class nameOfClass {
                 onLogoClicked(){
                    alert('Hello World');
                 }
             }
        => an alertbox will show 'Hello World', when the logo is clicked.

        in .css: (formatting the file)


3. automatic synchronisation between data and view:
    If you adapt .ts -, it will be automatically adjusted on the view

4. security features (build in security)

== build a new component

Go to command line, stop the server and put the following command:

 ng generate component nameComponent

=> folder is created with

 .ts :
    import { Component, OnInit } from '@angular/cor';
    import {COURSES} from '../db-data';

    @component({
        selector:'nameComponent',    // defines to which HTML it belongs to  !!! OPM!!!
        templateUrl:'./nameComponent.component.html',    // points to the location in the file system of template file
        styleUrl: ['./nameComponent.component.css']
    }
    export class nameComponent implements OnIt {
            constructor() {}
            ngOnIt(){
            }
    };

 .css (to style this component)

 .html (empty)
you have to add code, f.e. a div
<div class = "nameComponent">
  ......
</div>

!! in app.component.html,

  <nameComponent></nameComponent>   !!!OPM!!!
  <nameComponent></nameComponent>
  ...                               // you can add this component as many times as you want
needs te be added

!!! OPM!!! these names should be exactly the same!!!


=== make an array accessible in the project
Make a db-data.ts in de src folder and put an array in it with some objects.

 export const COURSE: any = [
    {
    id=1,
    description: "test"
    ...
    }
    {
    ...
    }
]

You can make this data available in template (.htlm) file by making a variable in the app.component.ts file:

 import { Component } from '@angular/cor';
 import {COURSES} from '../db-data';

 @Component({
 selector:'app-root',
 templateUrl: './app.component.html'.
 styleUrls: [./app.component.css']
 })

 export class AppComponent{
    coreCourse = COURSES [0];
    AngularCourse = COURSE [1];
    ....
    }

now in the html file, you can enter it by

  {{coreCourse.description}}, {{AngularCourse.description}}


OR inside a component we call in the html

  <nameComponent [title]= "AngularCourse.description"></nameComponent>

this element should also be added in the class nameComponentComponent (nameComponent.Component.ts)

  import { Component, OnInit } from '@angular/cor';
  import {COURSES} from '../db-data';

    @component({
        selector:'nameComponent',
// defines to which HTML it belongs to  !!! OPM!!!
        templateUrl:'./nameComponent.component.html',
// points to the location in the file system of template file
        styleUrl: ['./nameComponent.component.css']
    }
    export class nameComponent implements OnIt {
            @Input()                 // by this, Angular knows it is an input property
            title:string;            // of the  <nameComponent></nameComponent> from the html
            constructor() {}
            ngOnIt(){
            }
    };

This way, we can adapt a component, over and over again when you call it in the html.


=== ng For-loop
- NgFor does support arrays and array-like objects as well
- NgFor allows us to loop over data and access each value and index
- NgFor is a structural directive, meaning that it changes the structure of the DOM.
- Its point is to repeat a given HTML template once for each value in an array,
each time passing it the array value as context for string interpolation or binding.

- The syntax is

 *ngFor="let <value> of <collection>".     // *ngFor=let language of languages

<value> is a variable name of your choosing, <collection> is a property on your component which holds a collection,
usually an array but anything that can be iterated over in a for-of loop.


=== Building a template-driven form
https://angular.io/guide/forms

Template-driven forms use two-way data binding to update the data model in the component
as changes are made in the template and vice versa.
Template-driven forms are suitable for small or simple forms, while reactive forms are more scalable and suitable for complex forms


[]
